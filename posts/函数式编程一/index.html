<!DOCTYPE html>
<html lang="zh-cn">
	<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Nam">
<meta name="description" content="Nam&#39;s blog">
<meta name="generator" content="Hugo 0.59.0" />
<title>函数式编程(一)</title>
<link rel="shortcut icon" href="https://www.nams.site/images/favicon.ico">
<link rel="stylesheet" href="https://www.nams.site/css/style.css">
<link rel="stylesheet" href="https://www.nams.site/css/highlight.css">



<link rel="stylesheet" href="https://www.nams.site/css/monosocialiconsfont.css">



<link href="https://www.nams.site/index.xml" rel="alternate" type="application/rss+xml" title="Nam&#39;s" />


<meta property="og:title" content="函数式编程(一)" />
<meta property="og:description" content="在了解函数式编程之前，我们先来讨论一个问题：什么函数？
编程时，我们在谈论函数的时候，总是默认它为命令式编程里的子程序。
子程序，英文里称为subroutine或者subprogram，顾名思义，就是指一个计算机程序中的某部分代码，它由一个或多个语句块组成它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。
function (x) { … }  它一般类似于这种形式，会有输入参数并有返回值，提供对过程的封装和细节的隐藏，但是，在我们接下来的讨论中，我希望大家忘记函数的这种形式，因为我们即将进入数学里的函数，如果你把编程时常写x=x&#43;1给你的数学老师看，他应该会打你吧。
在数学里，我们可以把函数看作两个不为空的集合间的一种对应关系，输入值集合中的每项元素皆能对应唯一一项输出值集合中的元素。例如实数x对应到其平方x2的关系就是一个函数，若以3作为此函数的输入值，所得的输出值便是9：
我们用数学式把这个关系写出来就是一个我们每个人都见过的式子：
函数将有效的输入值变换为唯一的输出值，同一输入总是对应同一输出，但反之未必成立。因此如Root(x)=正负sqrt(x)这样的表达式并没有定义出一个函数，因为输出值有两个可能。定义函数时需确定每一个输入值只对应唯一输出值，因此必须明确地选择一个平方根。例如定义Posroot(x)=sqrt(x)，亦即对于任何非负输入值，选择其非负平方根作为函数值。
那么什么是函数式编程呢？
我们先对它下一个定义：它是一种以Lambda为其语言基础的编程范式，就像面向对象编程，命令式编程一样，是一类典型的编程风格。
Lambda演算是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。它是一种抽象计算模型，是解决可计算问题的一种方案，通俗来讲，就是将计算以数学的方式抽象化，以便证明和推导。
Lambda演算的定义为：
比如我们定一个lambda表达式：
当这个表达式应用于具体的变量时，需要用一对括号把表达式括起来，应用过程是把变量值赋值给表达式中的x，并去掉 λ&lt;变量&gt;：
看到这里是不是熟悉了很多，这其实就对应着程序语言中的函数定义，参数传递，函数调用。函数式编程语言Lisp表达的也正是这种形式。
那如果是多个变量呢？
可能有人会有疑问，如果以lambda演算为语言基础，那么语言中的boolean、number、list这些数据类型怎么办？
有这种疑问的同学，你距离真正的乐趣已经很近了，Lambda演算有其强大的秘笈，那就是不关心数据的值是什么，重点是能对这个值做什么操作。
以布尔值为例大家想一想我们平时都把布尔值用在什么地方？
对，条件判断。
因为其实我们是无法直观的看出一个值是true还是false，而是根据条件判断返回的值来判断，在Lambda演算中，我们可以这样定义布尔值（感兴趣的同学可以自己去搜索一下推导过程）：
介绍完Lambda，下面我们来定义一下函数式编程范式：
在函数式的编程范式里，把计算机运算视为函数运算，也就是说一个程序会被看作是一个无状态的函数计算的序列；最后，在函数式编程里，应该避免使用程序状态以及易变对象。
之前我们介绍了的数学里的函数，函数的运算，也就是一个映射的过程。这听起来很抽象，我们先来举个例子，假如现在你正在面试，面试官出了一道题给你：把二叉树镜像翻转一下。然后你不假思索，写下了如下代码：
function invertTree(node) { if (!node) return; [node.left, node.right] = [invertTree(node.right), invertTree(node.left)]; return node; }  好了，我们现在停下来看看这段代码究竟代表着什么：首先判断节点是否为空；然后翻转左树；然后翻转右树；最后左右互换。这就是命令式编程——你要做什么事情，你得把达到目的的步骤详细的描述出来，然后交给机器去运行。
这也正是命令式编程的理论模型——图灵机的特点。一条写满数据的纸带，一条根据纸带内容运动的机器，机器每动一步都需要纸带上写着如何达到。
我们用函数的思维来重新思考一下这个问题，所谓“翻转二叉树”，可以看做是要得到一颗和原来二叉树对称的新二叉树。这颗新二叉树的特点是每一个节点都递归地和原树相反。基于这种映射关系，我们重新写出以下的代码：
function invertTree(node) { // 省略Tree和invert的实现 if(!node) return; return Tree(node.value, invert(node.right), invert(node.left)); }  乍一看与之前的代码区别并不大，只是创建了一个新的树并返回，但其得到结果的方式与之前的代码有着本质的差别，这段代码通过描述一个旧树-&gt;新树的映射，而不是描述「从旧树得到新树应该怎样做」来达到目的。
这就是函数运算，它是“对映射和关系的描述”，它不仅可以描述二叉树这样的数据结构之间的对应关系，任何能在计算机中体现的东西之间的对应关系都可以描述——比如函数和函数之间的映射；比如外部操作到 GUI 之间的映射。我们把寻找这种映射关系的过程抽象，也就是推导lambda演算的过程。
正如平时我们都知道的函数式法则一样，不要去修改传入的值，而是根据它去计算一个新的值。这正是imutable的思想，也是之后React、Redux等框架的基石。
但凡事都有正反两面，函数式编程也不例外。
首先最明显的好处就是引用透明和没有副作用，函数调用的结果不依赖调用的时间和位置，对于相同的输入，函数总是返回相同的输出，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。此外，如今计算机计算能力的增长已经不依赖CPU主频的增长，而是依赖CPU核数的增多，在多核环境下的程序设计的难点就在于对共享可变状态的管理，函数即不依赖外部的状态也不修改外部的状态，使得并行更加容易。而函数作为一等公民，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，也可以对函数进行组合。
当然，它的缺点也很明显：
如果某个映射关系很复杂，需要许多函数组合运算，过长的函数组合可能会影响代码的可读性。其次在函数式编程中没有循环，所以必须使用递归来达到循环的功能，这对编写带来了挑战，因为没有可变的状态来存储中间值，在一些复杂运算中需要更多的内存和计算时间，这将导致性能的下降。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.nams.site/posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%80/" />
<meta property="article:published_time" content="2019-04-07T14:15:39+08:00" />
<meta property="article:modified_time" content="2019-04-07T14:15:39+08:00" />


<meta itemprop="name" content="函数式编程(一)">
<meta itemprop="description" content="在了解函数式编程之前，我们先来讨论一个问题：什么函数？
编程时，我们在谈论函数的时候，总是默认它为命令式编程里的子程序。
子程序，英文里称为subroutine或者subprogram，顾名思义，就是指一个计算机程序中的某部分代码，它由一个或多个语句块组成它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。
function (x) { … }  它一般类似于这种形式，会有输入参数并有返回值，提供对过程的封装和细节的隐藏，但是，在我们接下来的讨论中，我希望大家忘记函数的这种形式，因为我们即将进入数学里的函数，如果你把编程时常写x=x&#43;1给你的数学老师看，他应该会打你吧。
在数学里，我们可以把函数看作两个不为空的集合间的一种对应关系，输入值集合中的每项元素皆能对应唯一一项输出值集合中的元素。例如实数x对应到其平方x2的关系就是一个函数，若以3作为此函数的输入值，所得的输出值便是9：
我们用数学式把这个关系写出来就是一个我们每个人都见过的式子：
函数将有效的输入值变换为唯一的输出值，同一输入总是对应同一输出，但反之未必成立。因此如Root(x)=正负sqrt(x)这样的表达式并没有定义出一个函数，因为输出值有两个可能。定义函数时需确定每一个输入值只对应唯一输出值，因此必须明确地选择一个平方根。例如定义Posroot(x)=sqrt(x)，亦即对于任何非负输入值，选择其非负平方根作为函数值。
那么什么是函数式编程呢？
我们先对它下一个定义：它是一种以Lambda为其语言基础的编程范式，就像面向对象编程，命令式编程一样，是一类典型的编程风格。
Lambda演算是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。它是一种抽象计算模型，是解决可计算问题的一种方案，通俗来讲，就是将计算以数学的方式抽象化，以便证明和推导。
Lambda演算的定义为：
比如我们定一个lambda表达式：
当这个表达式应用于具体的变量时，需要用一对括号把表达式括起来，应用过程是把变量值赋值给表达式中的x，并去掉 λ&lt;变量&gt;：
看到这里是不是熟悉了很多，这其实就对应着程序语言中的函数定义，参数传递，函数调用。函数式编程语言Lisp表达的也正是这种形式。
那如果是多个变量呢？
可能有人会有疑问，如果以lambda演算为语言基础，那么语言中的boolean、number、list这些数据类型怎么办？
有这种疑问的同学，你距离真正的乐趣已经很近了，Lambda演算有其强大的秘笈，那就是不关心数据的值是什么，重点是能对这个值做什么操作。
以布尔值为例大家想一想我们平时都把布尔值用在什么地方？
对，条件判断。
因为其实我们是无法直观的看出一个值是true还是false，而是根据条件判断返回的值来判断，在Lambda演算中，我们可以这样定义布尔值（感兴趣的同学可以自己去搜索一下推导过程）：
介绍完Lambda，下面我们来定义一下函数式编程范式：
在函数式的编程范式里，把计算机运算视为函数运算，也就是说一个程序会被看作是一个无状态的函数计算的序列；最后，在函数式编程里，应该避免使用程序状态以及易变对象。
之前我们介绍了的数学里的函数，函数的运算，也就是一个映射的过程。这听起来很抽象，我们先来举个例子，假如现在你正在面试，面试官出了一道题给你：把二叉树镜像翻转一下。然后你不假思索，写下了如下代码：
function invertTree(node) { if (!node) return; [node.left, node.right] = [invertTree(node.right), invertTree(node.left)]; return node; }  好了，我们现在停下来看看这段代码究竟代表着什么：首先判断节点是否为空；然后翻转左树；然后翻转右树；最后左右互换。这就是命令式编程——你要做什么事情，你得把达到目的的步骤详细的描述出来，然后交给机器去运行。
这也正是命令式编程的理论模型——图灵机的特点。一条写满数据的纸带，一条根据纸带内容运动的机器，机器每动一步都需要纸带上写着如何达到。
我们用函数的思维来重新思考一下这个问题，所谓“翻转二叉树”，可以看做是要得到一颗和原来二叉树对称的新二叉树。这颗新二叉树的特点是每一个节点都递归地和原树相反。基于这种映射关系，我们重新写出以下的代码：
function invertTree(node) { // 省略Tree和invert的实现 if(!node) return; return Tree(node.value, invert(node.right), invert(node.left)); }  乍一看与之前的代码区别并不大，只是创建了一个新的树并返回，但其得到结果的方式与之前的代码有着本质的差别，这段代码通过描述一个旧树-&gt;新树的映射，而不是描述「从旧树得到新树应该怎样做」来达到目的。
这就是函数运算，它是“对映射和关系的描述”，它不仅可以描述二叉树这样的数据结构之间的对应关系，任何能在计算机中体现的东西之间的对应关系都可以描述——比如函数和函数之间的映射；比如外部操作到 GUI 之间的映射。我们把寻找这种映射关系的过程抽象，也就是推导lambda演算的过程。
正如平时我们都知道的函数式法则一样，不要去修改传入的值，而是根据它去计算一个新的值。这正是imutable的思想，也是之后React、Redux等框架的基石。
但凡事都有正反两面，函数式编程也不例外。
首先最明显的好处就是引用透明和没有副作用，函数调用的结果不依赖调用的时间和位置，对于相同的输入，函数总是返回相同的输出，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。此外，如今计算机计算能力的增长已经不依赖CPU主频的增长，而是依赖CPU核数的增多，在多核环境下的程序设计的难点就在于对共享可变状态的管理，函数即不依赖外部的状态也不修改外部的状态，使得并行更加容易。而函数作为一等公民，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，也可以对函数进行组合。
当然，它的缺点也很明显：
如果某个映射关系很复杂，需要许多函数组合运算，过长的函数组合可能会影响代码的可读性。其次在函数式编程中没有循环，所以必须使用递归来达到循环的功能，这对编写带来了挑战，因为没有可变的状态来存储中间值，在一些复杂运算中需要更多的内存和计算时间，这将导致性能的下降。">


<meta itemprop="datePublished" content="2019-04-07T14:15:39&#43;08:00" />
<meta itemprop="dateModified" content="2019-04-07T14:15:39&#43;08:00" />
<meta itemprop="wordCount" content="70">



<meta itemprop="keywords" content="" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="函数式编程(一)"/>
<meta name="twitter:description" content="在了解函数式编程之前，我们先来讨论一个问题：什么函数？
编程时，我们在谈论函数的时候，总是默认它为命令式编程里的子程序。
子程序，英文里称为subroutine或者subprogram，顾名思义，就是指一个计算机程序中的某部分代码，它由一个或多个语句块组成它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。
function (x) { … }  它一般类似于这种形式，会有输入参数并有返回值，提供对过程的封装和细节的隐藏，但是，在我们接下来的讨论中，我希望大家忘记函数的这种形式，因为我们即将进入数学里的函数，如果你把编程时常写x=x&#43;1给你的数学老师看，他应该会打你吧。
在数学里，我们可以把函数看作两个不为空的集合间的一种对应关系，输入值集合中的每项元素皆能对应唯一一项输出值集合中的元素。例如实数x对应到其平方x2的关系就是一个函数，若以3作为此函数的输入值，所得的输出值便是9：
我们用数学式把这个关系写出来就是一个我们每个人都见过的式子：
函数将有效的输入值变换为唯一的输出值，同一输入总是对应同一输出，但反之未必成立。因此如Root(x)=正负sqrt(x)这样的表达式并没有定义出一个函数，因为输出值有两个可能。定义函数时需确定每一个输入值只对应唯一输出值，因此必须明确地选择一个平方根。例如定义Posroot(x)=sqrt(x)，亦即对于任何非负输入值，选择其非负平方根作为函数值。
那么什么是函数式编程呢？
我们先对它下一个定义：它是一种以Lambda为其语言基础的编程范式，就像面向对象编程，命令式编程一样，是一类典型的编程风格。
Lambda演算是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。它是一种抽象计算模型，是解决可计算问题的一种方案，通俗来讲，就是将计算以数学的方式抽象化，以便证明和推导。
Lambda演算的定义为：
比如我们定一个lambda表达式：
当这个表达式应用于具体的变量时，需要用一对括号把表达式括起来，应用过程是把变量值赋值给表达式中的x，并去掉 λ&lt;变量&gt;：
看到这里是不是熟悉了很多，这其实就对应着程序语言中的函数定义，参数传递，函数调用。函数式编程语言Lisp表达的也正是这种形式。
那如果是多个变量呢？
可能有人会有疑问，如果以lambda演算为语言基础，那么语言中的boolean、number、list这些数据类型怎么办？
有这种疑问的同学，你距离真正的乐趣已经很近了，Lambda演算有其强大的秘笈，那就是不关心数据的值是什么，重点是能对这个值做什么操作。
以布尔值为例大家想一想我们平时都把布尔值用在什么地方？
对，条件判断。
因为其实我们是无法直观的看出一个值是true还是false，而是根据条件判断返回的值来判断，在Lambda演算中，我们可以这样定义布尔值（感兴趣的同学可以自己去搜索一下推导过程）：
介绍完Lambda，下面我们来定义一下函数式编程范式：
在函数式的编程范式里，把计算机运算视为函数运算，也就是说一个程序会被看作是一个无状态的函数计算的序列；最后，在函数式编程里，应该避免使用程序状态以及易变对象。
之前我们介绍了的数学里的函数，函数的运算，也就是一个映射的过程。这听起来很抽象，我们先来举个例子，假如现在你正在面试，面试官出了一道题给你：把二叉树镜像翻转一下。然后你不假思索，写下了如下代码：
function invertTree(node) { if (!node) return; [node.left, node.right] = [invertTree(node.right), invertTree(node.left)]; return node; }  好了，我们现在停下来看看这段代码究竟代表着什么：首先判断节点是否为空；然后翻转左树；然后翻转右树；最后左右互换。这就是命令式编程——你要做什么事情，你得把达到目的的步骤详细的描述出来，然后交给机器去运行。
这也正是命令式编程的理论模型——图灵机的特点。一条写满数据的纸带，一条根据纸带内容运动的机器，机器每动一步都需要纸带上写着如何达到。
我们用函数的思维来重新思考一下这个问题，所谓“翻转二叉树”，可以看做是要得到一颗和原来二叉树对称的新二叉树。这颗新二叉树的特点是每一个节点都递归地和原树相反。基于这种映射关系，我们重新写出以下的代码：
function invertTree(node) { // 省略Tree和invert的实现 if(!node) return; return Tree(node.value, invert(node.right), invert(node.left)); }  乍一看与之前的代码区别并不大，只是创建了一个新的树并返回，但其得到结果的方式与之前的代码有着本质的差别，这段代码通过描述一个旧树-&gt;新树的映射，而不是描述「从旧树得到新树应该怎样做」来达到目的。
这就是函数运算，它是“对映射和关系的描述”，它不仅可以描述二叉树这样的数据结构之间的对应关系，任何能在计算机中体现的东西之间的对应关系都可以描述——比如函数和函数之间的映射；比如外部操作到 GUI 之间的映射。我们把寻找这种映射关系的过程抽象，也就是推导lambda演算的过程。
正如平时我们都知道的函数式法则一样，不要去修改传入的值，而是根据它去计算一个新的值。这正是imutable的思想，也是之后React、Redux等框架的基石。
但凡事都有正反两面，函数式编程也不例外。
首先最明显的好处就是引用透明和没有副作用，函数调用的结果不依赖调用的时间和位置，对于相同的输入，函数总是返回相同的输出，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。此外，如今计算机计算能力的增长已经不依赖CPU主频的增长，而是依赖CPU核数的增多，在多核环境下的程序设计的难点就在于对共享可变状态的管理，函数即不依赖外部的状态也不修改外部的状态，使得并行更加容易。而函数作为一等公民，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，也可以对函数进行组合。
当然，它的缺点也很明显：
如果某个映射关系很复杂，需要许多函数组合运算，过长的函数组合可能会影响代码的可读性。其次在函数式编程中没有循环，所以必须使用递归来达到循环的功能，这对编写带来了挑战，因为没有可变的状态来存储中间值，在一些复杂运算中需要更多的内存和计算时间，这将导致性能的下降。"/>


    </head>
<body>
    <nav class="main-nav">
	
		<a href='https://www.nams.site/'> <span class="arrow">←</span>Home</a>
	

	

	
		<a class="cta" href="https://www.nams.site/index.xml">Subscribe</a>
	
</nav>

    <section id="wrapper">
        
        
<article class="post">
    <header>
        <h1>函数式编程(一)</h1>
        <h2 class="subtitle"></h2>
        <h2 class="headline">
        April 7, 2019
        <br>
        
        </h2>
    </header>
    <section id="post-body">
        <p>在了解函数式编程之前，我们先来讨论一个问题：什么函数？</p>

<p>编程时，我们在谈论函数的时候，总是默认它为命令式编程里的<strong>子程序。</strong></p>

<p><img src="/Users/nam/Library/Application Support/typora-user-images/image-20200407142018417.png" alt="image-20200407142018417" style="zoom: 33%;" /></p>

<p>子程序，英文里称为subroutine或者subprogram，顾名思义，就是指一个计算机程序中的某部分代码，它由一个或多个语句块组成它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。</p>

<pre><code class="language-javascript">function (x) {
   …
}
</code></pre>

<p>它一般类似于这种形式，会有输入参数并有返回值，提供对过程的封装和细节的隐藏，但是，在我们接下来的讨论中，我希望大家忘记函数的这种形式，因为我们即将进入<strong>数学里的函数</strong>，如果你把编程时常写x=x+1给你的数学老师看，他应该会打你吧。</p>

<p>在数学里，我们可以把函数看作两个不为空的集合间的一种对应关系，输入值集合中的每项元素皆能对应唯一一项输出值集合中的元素。例如实数x对应到其平方x2的关系就是一个函数，若以3作为此函数的输入值，所得的输出值便是9：</p>

<p><img src="/Users/nam/Library/Application Support/typora-user-images/image-20200407142331767.png" alt="image-20200407142331767" style="zoom: 33%;" /></p>

<p>我们用数学式把这个关系写出来就是一个我们每个人都见过的式子：</p>

<p><img src="/Users/nam/Library/Application Support/typora-user-images/image-20200407142436016.png" alt="image-20200407142436016" style="zoom: 33%;" /></p>

<p>函数将有效的输入值变换为唯一的输出值，同一输入总是对应同一输出，但反之未必成立。因此如Root(x)=正负sqrt(x)这样的表达式并没有定义出一个函数，因为输出值有两个可能。定义函数时需确定每一个输入值只对应唯一输出值，因此必须明确地选择一个平方根。例如定义Posroot(x)=sqrt(x)，亦即对于任何非负输入值，选择其非负平方根作为函数值。</p>

<p>那么什么是函数式编程呢？</p>

<p>我们先对它下一个定义：它是一种以<strong>Lambda</strong>为其语言基础的<strong>编程范式</strong>，就像面向对象编程，命令式编程一样，是一类典型的<strong>编程风格</strong>。</p>

<p>Lambda演算是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。它是一种抽象计算模型，是解决可计算问题的一种方案，通俗来讲，就是将计算以数学的方式抽象化，以便证明和推导。</p>

<p>Lambda演算的定义为：</p>

<p><img src="/Users/nam/Library/Application Support/typora-user-images/image-20200407143151599.png" alt="image-20200407143151599" style="zoom: 33%;" /></p>

<p>比如我们定一个lambda表达式：</p>

<p><img src="/Users/nam/Library/Application Support/typora-user-images/image-20200407143314009.png" alt="image-20200407143314009" style="zoom: 33%;" /></p>

<p>当这个表达式应用于具体的变量时，需要用一对括号把表达式括起来，应用过程是把变量值赋值给表达式中的x，并去掉 λ&lt;变量&gt;：</p>

<p><img src="/Users/nam/Library/Application Support/typora-user-images/image-20200407143405738.png" alt="image-20200407143405738" style="zoom: 33%;" /></p>

<p>看到这里是不是熟悉了很多，这其实就对应着程序语言中的<strong>函数定义，参数传递，函数调用</strong>。函数式编程语言Lisp表达的也正是这种形式。</p>

<p>那如果是多个变量呢？</p>

<p><img src="/Users/nam/Library/Application Support/typora-user-images/image-20200407143717049.png" alt="image-20200407143717049" style="zoom: 33%;" /></p>

<p>可能有人会有疑问，如果以lambda演算为语言基础，那么语言中的boolean、number、list这些数据类型怎么办？</p>

<p>有这种疑问的同学，你距离真正的乐趣已经很近了，Lambda演算有其强大的秘笈，那就是<strong>不关心数据的值是什么，重点是能对这个值做什么操作</strong>。</p>

<p>以布尔值为例大家想一想我们平时都把布尔值用在什么地方？</p>

<p>对，条件判断。</p>

<p>因为其实我们是无法直观的看出一个值是true还是false，而是根据条件判断返回的值来判断，在Lambda演算中，我们可以这样定义布尔值（感兴趣的同学可以自己去搜索一下推导过程）：</p>

<p><img src="/Users/nam/Library/Application Support/typora-user-images/image-20200407144303904.png" alt="image-20200407144303904" style="zoom:33%;" /></p>

<p>介绍完Lambda，下面我们来定义一下函数式编程范式：</p>

<p>在函数式的编程范式里，把计算机运算视为函数运算，也就是说一个程序会被看作是一个无状态的函数计算的序列；最后，在函数式编程里，应该避免使用程序状态以及易变对象。</p>

<p>之前我们介绍了的数学里的函数，函数的运算，也就是一个映射的过程。这听起来很抽象，我们先来举个例子，假如现在你正在面试，面试官出了一道题给你：把二叉树镜像翻转一下。然后你不假思索，写下了如下代码：</p>

<pre><code class="language-javascript">function invertTree(node) {
    if (!node) return;
    [node.left, node.right] = [invertTree(node.right), invertTree(node.left)];
    return node;
}
</code></pre>

<p>好了，我们现在停下来看看这段代码究竟代表着什么：首先判断节点是否为空；然后翻转左树；然后翻转右树；最后左右互换。这就是命令式编程——你要做什么事情，你得把达到目的的步骤详细的描述出来，然后交给机器去运行。</p>

<p>这也正是命令式编程的理论模型——图灵机的特点。一条写满数据的纸带，一条根据纸带内容运动的机器，机器每动一步都需要纸带上写着如何达到。</p>

<p>我们用函数的思维来重新思考一下这个问题，所谓“翻转二叉树”，可以看做是要得到一颗和原来二叉树对称的新二叉树。这颗新二叉树的特点是每一个节点都递归地和原树相反。基于这种映射关系，我们重新写出以下的代码：</p>

<pre><code class="language-javascript">function invertTree(node) {
  // 省略Tree和invert的实现
    if(!node) return;
    return Tree(node.value, invert(node.right), invert(node.left));
}
</code></pre>

<p>乍一看与之前的代码区别并不大，只是创建了一个新的树并返回，但其得到结果的方式与之前的代码有着本质的差别，这段代码通过描述一个<strong>旧树-&gt;新树的映射</strong>，而不是描述「从旧树得到新树应该怎样做」来达到目的。</p>

<p>这就是函数运算，它是<strong>“对映射和关系的描述”</strong>，它不仅可以描述二叉树这样的数据结构之间的对应关系，任何能在计算机中体现的东西之间的对应关系都可以描述——比如函数和函数之间的映射；比如外部操作到 GUI 之间的映射。我们把寻找这种映射关系的过程抽象，也就是推导lambda演算的过程。</p>

<p>正如平时我们都知道的函数式法则一样，不要去修改传入的值，而是根据它去计算一个新的值。这正是imutable的思想，也是之后React、Redux等框架的基石。</p>

<p>但凡事都有正反两面，函数式编程也不例外。</p>

<p>首先最明显的好处就是引用透明和没有副作用，函数调用的结果不依赖调用的时间和位置，对于相同的输入，函数总是返回相同的输出，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。此外，如今计算机计算能力的增长已经不依赖CPU主频的增长，而是依赖CPU核数的增多，在多核环境下的程序设计的难点就在于对共享可变状态的管理，函数即不依赖外部的状态也不修改外部的状态，使得并行更加容易。而函数作为一等公民，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，也可以对函数进行组合。</p>

<p>当然，它的缺点也很明显：</p>

<p>如果某个映射关系很复杂，需要许多函数组合运算，过长的函数组合可能会影响代码的可读性。其次在函数式编程中没有循环，所以必须使用递归来达到循环的功能，这对编写带来了挑战，因为没有可变的状态来存储中间值，在一些复杂运算中需要更多的内存和计算时间，这将导致性能的下降。</p>

<hr />

<p>函数式编程可能听起来高大上，实际上也不过是众多编程范式的一种，学会函数式编程，并不代表拥有了屠龙的宝刀。对于计算机科学而言，核心永远应该是“<strong>如何解决问题</strong>”，而不是“<strong>这个概念、架构、模型、语言能够做什么</strong>”。就连计算机本身，最初都是为了军事上的目标而被创造出来的。是“<strong>要解决的问题</strong>”决定了计算机是什么样子，计算机科学是什么样子，而不是反之。</p>

<p>所以就程序的编写而言，写下代码只是最后的一步。<strong>对问题的理解、对解决方案的理解才是重心</strong>。“解决方案”在想好之后，再被映射到程序设计语言中。</p>

<p>希望大家知道为什么以及何时使用，而不是单纯的为了使用而使用。</p>

    </section>
</article>

<footer id="post-meta" class="clearfix">
    
    <img class="avatar" src="https://www.nams.site/images/avatar.png">
    <div>
        <span class="dark">Nam</span>
        <span>在路上</span>
    </div>
    
    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fwww.nams.site%2fposts%2f%25E5%2587%25BD%25E6%2595%25B0%25E5%25BC%258F%25E7%25BC%2596%25E7%25A8%258B%25E4%25B8%2580%2f - %e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%28%e4%b8%80%29 "><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

    </section>
</footer>



<ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="https://www.nams.site/posts/how-to-use-proxy/">How to use Proxy<aside class="dates">Feb 3 2018</aside></a>
        </li>
    
        <li>
            <a href="https://www.nams.site/posts/%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/">一道面试题<aside class="dates">Jan 10 2018</aside></a>
        </li>
    
        <li>
            <a href="https://www.nams.site/posts/js%E9%87%8C%E7%9A%84%E7%BB%A7%E6%89%BF/">Js里的继承<aside class="dates">Jan 2 2018</aside></a>
        </li>
    
        <li>
            <a href="https://www.nams.site/posts/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/">对象的创建<aside class="dates">Dec 27 2017</aside></a>
        </li>
    
        <li>
            <a href="https://www.nams.site/posts/this%E6%8C%87%E5%90%91/">This指向<aside class="dates">Oct 22 2017</aside></a>
        </li>
    
        <li>
            <a href="https://www.nams.site/posts/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">Js的基本类型<aside class="dates">Jan 1 0001</aside></a>
        </li>
    
</ul>



        <footer id="footer">
    
        <div id="social">

	
	
    
    <a class="symbol" href="https://Lennam.github.com/">
        circlegithub
    </a>
    


</div>

    
    <p class="small">
    
        © Copyright 2020 Nam
    
    </p>
</footer>

    </section>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="https://www.nams.site/js/main.js"></script>
<script src="https://www.nams.site/js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script>





</body>
</html>
