<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Nam&#39;s</title>
    <link>/posts/</link>
    <description>Recent content in Posts on Nam&#39;s</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 22 Oct 2019 16:52:12 +0800</lastBuildDate>
    
	<atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>V8引擎里的内存管理</title>
      <link>/posts/v8%E5%BC%95%E6%93%8E%E9%87%8C%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 22 Oct 2019 16:52:12 +0800</pubDate>
      
      <guid>/posts/v8%E5%BC%95%E6%93%8E%E9%87%8C%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>React 开发教程</title>
      <link>/posts/react%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/</link>
      <pubDate>Fri, 30 Nov 2018 21:37:10 +0800</pubDate>
      
      <guid>/posts/react%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/</guid>
      <description>最近学了React，所以把自己学习React的笔记整理一下变成了这篇入门教程。
React官方文档描述React为函数式的，有的同学可能不太明白，前端明明涉及那么多有副作用的操作，例如DOM的操作和API的请求之类，为什么React会称自己为函数式的呢？
我们知道，无论是React、Vue或是Angular，它们的最终目的都是生成视图，而视图则是对当前数据的一种映射，在MVVM（关于MVVM可以参考我的另一篇博客）模式里面，我们并不直接操作View层，而是交给VM层自动生成，所以MVVM模式框架生成视图的过程中，我们可以看做：
数据 + Render = 视图
而MVVM模式的框架在生成视图的过程中就扮演了Render的角色。在函数式编程中，当一个函数接受相同的参数，它总是返回相同的结果。而在React中，我们提供了相同的数据，React总是渲染出相同的视图。那些带有副作用的操作，DOM改变和API请求，会先改变数据，然后经过Render最终改变视图，这就是React不建议我们直接操作DOM的原因，这会让视图的生成不可预测，并增加测试的难度。
那么我们如何使用React来构建视图呢？
过去我们不使用React之类的框架时，总是用一个HTML文件来表示一个用户界面，然而一个用户界面在很多时候是复杂的，当产生变化的时候，经常伴随许多DOM操作，所有我们还要提供一个又臭又长的js文件来维护用户界面的变化，当应用越来越懒复杂，用户界面越来越多的时候，可以预见这将是一场灾难。那如果我们不按用户界面来拆分应用呢？我们是否可以把用户界面看做一个个小的视图组成，每一个视图完成一个功能？显然，React这样做了。
在React中，推荐使用jsx来描述UI信息（你也可以使用其他的语言，但是React弄了一个视频来忽悠你），每一个jsx文件代表一个组件，我们需要根据单一职责原则把一个用户界面拆分为许多组件，组件分为函数式组件（或者称为无状态组件）和类组件，无论是函数式组件还是类组件都会返回一个React元素，这个过程是通过Babel把jsx编译成React.createElement()执行的：
图。。。
函数式组件形如一个javascript函数，它只接受props参数，并返回一个React元素，当我们使用函数式组件的时候，往往只把这个组件用于展示props传入的数据，而没有其他的逻辑，例如对用户的操作作出响应等，所以函数式组件没有自己内部的状态。我们可以看作：给它什么，它就显示并只专注于显示什么。你或许了解函数式编程，函数式组件也一样，当我们使用它的时候，应该禁止其修改传入的props。
图
而在类组件中，组件获得了更多的能力。它可以拥有自己的State（状态），同时它还拥有了在组件不同的生命周期里编写逻辑的能力，从而可以响应更复杂的变化。
（显然，在Facebook内部可能更喜欢函数式组件，否则它们就不会为函数式组件提供新特性Hooks并推荐你在新的代码中使用它了。）
假如我们现在要实现一个功能：有一个搜索框和一个表格用于搜索和展示电影。
首先拆分组件。我们可以把整个功能先看成一个组件，它实现了搜索和展示的功能，这样做当然可以，但如果在应用的另一个地方要实现某个单一的搜索或者展示功能呢？诚然，这样让组件无法复用。所以我们可以拆分为一个搜索组件和一个展示组件，这样使得我们的组件可以在其他地方复用（在应用的设计阶段可以和设计师沟通，把有相同功能的页面设计为一致的风格，如果他要为相同的功能都重新设计，那么就祝你幸福吧）。
现在我们把这个功能拆分为如下的组件构成：
图。。。
我们该如何选择函数式组件和类组件呢？
一个简单的方法就是我们先用类组件构建所有的组件，只实现功能的静态页面版本（只有界面，而没有任何的交互，只需要编写类组件里的render方法），并模拟一个电影数组，通过props传入MovieFilterableTable,然后再传入MovieTable组件。
显然，这个静态页面版本无法满足我们的功能需求，我们的组件需要更多的交互，React为我们提供了State来触发和更改底层的数据模型。
现在列举一下我们功能里的所有数据：
 搜索文本 初始电影列表 搜索后的电影列表  为了确定一个数据是不是State，React提供了几个提示：
 是否通过 props(属性) 从父级传入？ 如果是这样，它可能不是 state(状态) 。 是否永远不会发生变化？ 如果是这样，它可能不是 state(状态)。 是否可以由组件中其他的 state(状态) 或 props(属性) 计算得出？如果是这样，则它不是 state(状态)。  （你或许觉得啰嗦，当你熟悉了React构建应用后，你可以很快的确定哪些数据是state，哪些是props）
搜索文本不是通过props传入，会随着用户的输入改变。初始电影列表通过props传递，而搜索后的电影列表可以通过初试电影列表结合搜索文本计算得出。
所以在这个功能中，状态只有：
 搜索文本  接下来我们要思考该把这个state放在那个组件当中。在React中，数据自顶向下流动，假如搜索文本只有在SearchBar中才使用，那放入SearchBar或许是不错的选择，但在这个例子中，我们的MovieTable组件也需要搜索文本来决定需要展示哪些Movie，MovieTable和SearchBar处于同级，这会让state的共享变得困难，所以把它放入公共父组件并通过props传入SearchBar和MovieTable会是不错的选择。
对于State应该存放在哪个组件当中，React为我们提供了一些建议：
 确定每个基于这个 state(状态) 渲染的组件。 找出公共父级组件（一个单独的组件，在组件层级中位于所有需要这个 state(状态) 的组件的上面。愚人码头注：父级组件）。 公共父级组件 或者 另一个更高级组件拥有这个 state(状态) 。 如果找不出一个拥有该 state(状态) 的合适组件，可以创建一个简单的新组件来保留这个 state(状态) ，并将其添加到公共父级组件的上层即可。  （State和Props的规划，是React中非常重要的一部分，这往往会影响到你对应用的理解和代码的整洁）</description>
    </item>
    
    <item>
      <title>How to use Proxy</title>
      <link>/posts/how-to-use-proxy/</link>
      <pubDate>Sat, 03 Feb 2018 14:31:29 +0800</pubDate>
      
      <guid>/posts/how-to-use-proxy/</guid>
      <description>今天看到一篇关于Proxy的文章，挺有意思，所以翻译一下。
原文地址：How to use JavaScript Proxies for Fun and Profit
以下是翻译：
Javascript最近有一个新鲜的但未得到广泛使用的特性：JavaScript proxies.
使用Javascript proxies你可以包装一个现有的对象，并拦截对其属性或者方法的访问，即使这些属性或方法并不存在！
Hello World Proxy 让我们从一个基本的‘hello world’例子开始吧：
const wrap = obj =&amp;gt; { return new Proxy(obj, { get(target, propKey) { console.log(`Reading property &amp;quot;${propKey}&amp;quot;`) return target[propKey] } }) } const object = { message: &#39;hello world&#39; } const wrapped = wrap(object) console.log(wrapped.message)  这段代码输出：
Reading property &amp;quot;message&amp;quot; hello world  在这个例子中，我们只是访问对象的属性和方法前做了一些事。然后我们返回了原本的属性和方法。
你也可以用一个set函数来拦截对属性的修改。
这可能可以用于验证属性或类似的东西，但我认为这个新特性很有前景，我希望一些已Proxy为核心功能的框架出现。所以我一直在思考这些问题，然后有了一些创意：
一个20行代码关于API的SDK 如上所述，你可以拦截一个方法的调用…甚至这个方法不存在。当一个被Proxy代理的对象上的方法被调用时，get函数会被调用并返回一个动态生成的函数。如果不需要，你完全可以不去触碰被代理的对象。
根据这个思维，你可以解析被调用的方法，并在运行的时候动态实现它的功能！举个栗子，当我们使用api.getusers()调用的时候，可以用代理在API中创建一个GET/users。通过这个约定我们可以更进一步，让api.postItems({name: ‘Item name’})使用第一个参数作为请求主体来调用POST/items。</description>
    </item>
    
    <item>
      <title>一道面试题</title>
      <link>/posts/%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Wed, 10 Jan 2018 22:15:22 +0800</pubDate>
      
      <guid>/posts/%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>今天在知乎上看到一道JavaScript面试题:
var x = 20; var a = { x : 15, fn : function(){ var x = 30; return function(){ return this.x; }; } }; console.log(a.fn()); console.log((a.fn())()); console.log(a.fn()()); console.log(a.fn()() == (a.fn())()); console.log(a.fn().call(this)); console.log(a.fn().call(a));  第一个console.log输出:
function (){ return this.x; }  第二个console.log输出:
20  根据第一个输出，我们可以把第二个式子改为
console.log((function (){ return this.x; })());  这里的this指向全局对象，立即执行a.fn()返回全局变量x。 第三个console.log输出:
20  这里和第二输出的式子有些不同，函数式少了一个括号
console.log(function (){ return this.x; }());  我们在控制台输入下面的代码:
function (){ return this.x;	}()； //报错  这时控制台会报错，而当我们在函数外面加一个括号时:</description>
    </item>
    
    <item>
      <title>Js里的继承</title>
      <link>/posts/js%E9%87%8C%E7%9A%84%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Tue, 02 Jan 2018 16:50:08 +0800</pubDate>
      
      <guid>/posts/js%E9%87%8C%E7%9A%84%E7%BB%A7%E6%89%BF/</guid>
      <description>在其他的OO语言中，最常见的两种继承方式是接口继承和实现继承。
我们知道，在JS中函数是没有签名的，函数的命名参数只是为了便利，并不是必须的，就算没有命名参数，我们还可以通过arguments获得传入函数的参数，就是这么随意~
原型链 我们知道每个构造函数都有一个原型对象，原型对象又有一个指向构造函数的指针，而实例内部也有一个指向原型对象的指针，如果我们让原型对象指向另一个类型的实例，这时原型对象将包含一个指向另一个原型对象的指针，而另一个原型对象又是另一个类型的实例，如此层层递进，就形成了原型链：
function SuperType() { .... } function SubType() { .... } SubType.prototype = new SuperType();  当然，原型链存在一些问题，包含引用类型的原型属性会被所有实例共享，通过原型链进行继承的时候，原型会变成另一个类型的实例，于是，原先的实例属性也会变成现在的原型属性：
function SuperType() { this.names = [&#39;Nam&#39;, &#39;Leenam&#39;, &#39;Yang&#39;]; } function SubType() { } SubType.prototype = new SuperType(); const instance1 = new SubType(); instance1.names.push(&#39;Neil&#39;); console.log(instance1.names); // [&amp;quot;Nam&amp;quot;, &amp;quot;Leenam&amp;quot;, &amp;quot;Yang&amp;quot;, &amp;quot;Neil&amp;quot;] const instance2 = new SubType(); console.log(instance2.names); // [&amp;quot;Nam&amp;quot;, &amp;quot;Leenam&amp;quot;, &amp;quot;Yang&amp;quot;, &amp;quot;Neil&amp;quot;]  借用构造函数 在使用原型链的继承中，为了解决引用类型值的问题，开发人员开始使用一种叫做借用构造函数的方法，，即在子类型的构造函数中调用超类型的构造函数：
function SuperType() { this.names = [&#39;Nam&#39;, &#39;Leenam&#39;, &#39;Yang&#39;]; } function SubType() { // 借用构造函数 SuperType.</description>
    </item>
    
    <item>
      <title>This指向</title>
      <link>/posts/this%E6%8C%87%E5%90%91/</link>
      <pubDate>Sun, 22 Oct 2017 15:15:09 +0800</pubDate>
      
      <guid>/posts/this%E6%8C%87%E5%90%91/</guid>
      <description>刚学JS时，总是对this的指向摸不着头脑，所以对它的使用，总是小心翼翼，能避就避，但在一些场景中，不使用this，会让代码变得丑陋。比如：
function sayHi() { return &#39;Hello, I&#39;m &#39; + this.name; } const me = { name: &#39;Nam&#39; } sayHi.call(me); // Hello,I&#39;m Nam // 而当我们不使用this时，必须要显示的传入一个上下文对象 function sayHi(obj) { return &#39;Hello, I&#39;m &#39; + obj.name; } const me = { name: &#39;Nam&#39; } sayHi(me); // Hello,I&#39;m Nam  显然，this提供了一种更优雅的方式来隐式的传递一个对象。当我们使用的模式越来越复杂，显示的传递上下文对象会让代码变得越来越混乱，使用this就可以很好的解决这个问题。
this的指向 关于this的指向，总有一个原则：this总是指向调用调用函数的那个对象。
我们来看具体的栗子：
1.独立函数调用 var a = 1; function say() { console.log(this.a) } say(); // 1 // 当我们使用严格模式的时候 var a = 1; function say() { ‘use strict&#39;; console.</description>
    </item>
    
    <item>
      <title>Js的基本类型</title>
      <link>/posts/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</guid>
      <description>Javascript的内置类型总共有7种：
 Undefined Null String Number Boolean Symbol（ES6新增） Object  其中除了Object为引用类型外，其他都为基本类型。
我们可以使用 typeof 操作符来检测基本类型：
typeof undefined === &#39;undefined&#39;; // true typeof &#39;Nam&#39; === &#39;string&#39;; // true typeof 1106 === &#39;number&#39;; // true typeof true === &#39;boolean&#39;; // true typeof Symbol() === &#39;symbol&#39;; // true // 当我们使用typeof操作符对null进行验证的时候 typeof null; // ‘object&#39;, What?  可以看到，我们typeof null返回的是object类型，这是一个特殊情况，正确的返回应该是null，但是这个bug由来已久，在javascript中存在了近20年，如果对它进行修复，会牵扯到太多web系统，将会产生更多的bug，所以这个问题也许永远得不到修复了…
如果我们想检测null的类型，可以使用复合条件：
const a = null; (!a &amp;amp;&amp;amp; typeof a === &#39;object); // true  在javascript中，变量是没有类型的，只有值才有。</description>
    </item>
    
  </channel>
</rss>