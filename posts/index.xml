<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Nam&#39;s</title>
    <link>https://example.org/posts/</link>
    <description>Recent content in Posts on Nam&#39;s</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 03 Feb 2018 14:31:29 +0800</lastBuildDate>
    
	<atom:link href="https://example.org/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How to use Proxy</title>
      <link>https://example.org/posts/how-to-use-proxy/</link>
      <pubDate>Sat, 03 Feb 2018 14:31:29 +0800</pubDate>
      
      <guid>https://example.org/posts/how-to-use-proxy/</guid>
      <description>今天看到一篇关于Proxy的文章，挺有意思，所以翻译一下。
原文地址：How to use JavaScript Proxies for Fun and Profit
以下是翻译：
Javascript最近有一个新鲜的但未得到广泛使用的特性：JavaScript proxies.
使用Javascript proxies你可以包装一个现有的对象，并拦截对其属性或者方法的访问，即使这些属性或方法并不存在！
Hello World Proxy 让我们从一个基本的‘hello world’例子开始吧：
const wrap = obj =&amp;gt; { return new Proxy(obj, { get(target, propKey) { console.log(`Reading property &amp;quot;${propKey}&amp;quot;`) return target[propKey] } }) } const object = { message: &#39;hello world&#39; } const wrapped = wrap(object) console.log(wrapped.message)  这段代码输出：
Reading property &amp;quot;message&amp;quot; hello world  在这个例子中，我们只是访问对象的属性和方法前做了一些事。然后我们返回了原本的属性和方法。
你也可以用一个set函数来拦截对属性的修改。
这可能可以用于验证属性或类似的东西，但我认为这个新特性很有前景，我希望一些已Proxy为核心功能的框架出现。所以我一直在思考这些问题，然后有了一些创意：
一个20行代码关于API的SDK 如上所述，你可以拦截一个方法的调用…甚至这个方法不存在。当一个被Proxy代理的对象上的方法被调用时，get函数会被调用并返回一个动态生成的函数。如果不需要，你完全可以不去触碰被代理的对象。
根据这个思维，你可以解析被调用的方法，并在运行的时候动态实现它的功能！举个栗子，当我们使用api.getusers()调用的时候，可以用代理在API中创建一个GET/users。通过这个约定我们可以更进一步，让api.postItems({name: ‘Item name’})使用第一个参数作为请求主体来调用POST/items。</description>
    </item>
    
    <item>
      <title>一道面试题</title>
      <link>https://example.org/posts/%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Wed, 10 Jan 2018 22:15:22 +0800</pubDate>
      
      <guid>https://example.org/posts/%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>今天在知乎上看到一道JavaScript面试题:
var x = 20; var a = { x : 15, fn : function(){ var x = 30; return function(){ return this.x; }; } }; console.log(a.fn()); console.log((a.fn())()); console.log(a.fn()()); console.log(a.fn()() == (a.fn())()); console.log(a.fn().call(this)); console.log(a.fn().call(a));  第一个console.log输出:
function (){ return this.x; }  第二个console.log输出:
20  根据第一个输出，我们可以把第二个式子改为
console.log((function (){ return this.x; })());  这里的this指向全局对象，立即执行a.fn()返回全局变量x。 第三个console.log输出:
20  这里和第二输出的式子有些不同，函数式少了一个括号
console.log(function (){ return this.x; }());  我们在控制台输入下面的代码:
function (){ return this.x;	}()； //报错  这时控制台会报错，而当我们在函数外面加一个括号时:</description>
    </item>
    
    <item>
      <title>Js里的继承</title>
      <link>https://example.org/posts/js%E9%87%8C%E7%9A%84%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Tue, 02 Jan 2018 16:50:08 +0800</pubDate>
      
      <guid>https://example.org/posts/js%E9%87%8C%E7%9A%84%E7%BB%A7%E6%89%BF/</guid>
      <description>在其他的OO语言中，最常见的两种继承方式是接口继承和实现继承。
我们知道，在JS中函数是没有签名的，函数的命名参数只是为了便利，并不是必须的，就算没有命名参数，我们还可以通过arguments获得传入函数的参数，就是这么随意~
原型链 我们知道每个构造函数都有一个原型对象，原型对象又有一个指向构造函数的指针，而实例内部也有一个指向原型对象的指针，如果我们让原型对象指向另一个类型的实例，这时原型对象将包含一个指向另一个原型对象的指针，而另一个原型对象又是另一个类型的实例，如此层层递进，就形成了原型链：
function SuperType() { .... } function SubType() { .... } SubType.prototype = new SuperType();  当然，原型链存在一些问题，包含引用类型的原型属性会被所有实例共享，通过原型链进行继承的时候，原型会变成另一个类型的实例，于是，原先的实例属性也会变成现在的原型属性：
function SuperType() { this.names = [&#39;Nam&#39;, &#39;Leenam&#39;, &#39;Yang&#39;]; } function SubType() { } SubType.prototype = new SuperType(); const instance1 = new SubType(); instance1.names.push(&#39;Neil&#39;); console.log(instance1.names); // [&amp;quot;Nam&amp;quot;, &amp;quot;Leenam&amp;quot;, &amp;quot;Yang&amp;quot;, &amp;quot;Neil&amp;quot;] const instance2 = new SubType(); console.log(instance2.names); // [&amp;quot;Nam&amp;quot;, &amp;quot;Leenam&amp;quot;, &amp;quot;Yang&amp;quot;, &amp;quot;Neil&amp;quot;]  借用构造函数 在使用原型链的继承中，为了解决引用类型值的问题，开发人员开始使用一种叫做借用构造函数的方法，，即在子类型的构造函数中调用超类型的构造函数：
function SuperType() { this.names = [&#39;Nam&#39;, &#39;Leenam&#39;, &#39;Yang&#39;]; } function SubType() { // 借用构造函数 SuperType.</description>
    </item>
    
    <item>
      <title>This指向</title>
      <link>https://example.org/posts/this%E6%8C%87%E5%90%91/</link>
      <pubDate>Sun, 22 Oct 2017 15:15:09 +0800</pubDate>
      
      <guid>https://example.org/posts/this%E6%8C%87%E5%90%91/</guid>
      <description>刚学JS时，总是对this的指向摸不着头脑，所以对它的使用，总是小心翼翼，能避就避，但在一些场景中，不使用this，会让代码变得丑陋。比如：
function sayHi() { return &#39;Hello, I&#39;m &#39; + this.name; } const me = { name: &#39;Nam&#39; } sayHi.call(me); // Hello,I&#39;m Nam // 而当我们不使用this时，必须要显示的传入一个上下文对象 function sayHi(obj) { return &#39;Hello, I&#39;m &#39; + obj.name; } const me = { name: &#39;Nam&#39; } sayHi(me); // Hello,I&#39;m Nam  显然，this提供了一种更优雅的方式来隐式的传递一个对象。当我们使用的模式越来越复杂，显示的传递上下文对象会让代码变得越来越混乱，使用this就可以很好的解决这个问题。
this的指向 关于this的指向，总有一个原则：this总是指向调用调用函数的那个对象。
我们来看具体的栗子：
1.独立函数调用 var a = 1; function say() { console.log(this.a) } say(); // 1 // 当我们使用严格模式的时候 var a = 1; function say() { ‘use strict&#39;; console.</description>
    </item>
    
    <item>
      <title>Js的基本类型</title>
      <link>https://example.org/posts/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.org/posts/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</guid>
      <description>Javascript的内置类型总共有7种：
 Undefined Null String Number Boolean Symbol（ES6新增） Object  其中除了Object为引用类型外，其他都为基本类型。
我们可以使用 typeof 操作符来检测基本类型：
typeof undefined === &#39;undefined&#39;; // true typeof &#39;Nam&#39; === &#39;string&#39;; // true typeof 1106 === &#39;number&#39;; // true typeof true === &#39;boolean&#39;; // true typeof Symbol() === &#39;symbol&#39;; // true // 当我们使用typeof操作符对null进行验证的时候 typeof null; // ‘object&#39;, What?  可以看到，我们typeof null返回的是object类型，这是一个特殊情况，正确的返回应该是null，但是这个bug由来已久，在javascript中存在了近20年，如果对它进行修复，会牵扯到太多web系统，将会产生更多的bug，所以这个问题也许永远得不到修复了…
如果我们想检测null的类型，可以使用复合条件：
const a = null; (!a &amp;amp;&amp;amp; typeof a === &#39;object); // true  在javascript中，变量是没有类型的，只有值才有。</description>
    </item>
    
  </channel>
</rss>