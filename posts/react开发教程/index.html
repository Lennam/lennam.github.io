<!DOCTYPE html>
<html lang="zh-cn">
	<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Nam">
<meta name="description" content="Nam&#39;s blog">
<meta name="generator" content="Hugo 0.59.0" />
<title>React 开发教程</title>
<link rel="shortcut icon" href="/images/favicon.ico">
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight.css">



<link rel="stylesheet" href="/css/monosocialiconsfont.css">



<link href="/index.xml" rel="alternate" type="application/rss+xml" title="Nam&#39;s" />


<meta property="og:title" content="React 开发教程" />
<meta property="og:description" content="最近学了React，所以把自己学习React的笔记整理一下变成了这篇入门教程。
React官方文档描述React为函数式的，有的同学可能不太明白，前端明明涉及那么多有副作用的操作，例如DOM的操作和API的请求之类，为什么React会称自己为函数式的呢？
我们知道，无论是React、Vue或是Angular，它们的最终目的都是生成视图，而视图则是对当前数据的一种映射，在MVVM（关于MVVM可以参考我的另一篇博客）模式里面，我们并不直接操作View层，而是交给VM层自动生成，所以MVVM模式框架生成视图的过程中，我们可以看做：
数据 &#43; Render = 视图
而MVVM模式的框架在生成视图的过程中就扮演了Render的角色。在函数式编程中，当一个函数接受相同的参数，它总是返回相同的结果。而在React中，我们提供了相同的数据，React总是渲染出相同的视图。那些带有副作用的操作，DOM改变和API请求，会先改变数据，然后经过Render最终改变视图，这就是React不建议我们直接操作DOM的原因，这会让视图的生成不可预测，并增加测试的难度。
那么我们如何使用React来构建视图呢？
过去我们不使用React之类的框架时，总是用一个HTML文件来表示一个用户界面，然而一个用户界面在很多时候是复杂的，当产生变化的时候，经常伴随许多DOM操作，所有我们还要提供一个又臭又长的js文件来维护用户界面的变化，当应用越来越懒复杂，用户界面越来越多的时候，可以预见这将是一场灾难。那如果我们不按用户界面来拆分应用呢？我们是否可以把用户界面看做一个个小的视图组成，每一个视图完成一个功能？显然，React这样做了。
在React中，推荐使用jsx来描述UI信息（你也可以使用其他的语言，但是React弄了一个视频来忽悠你），每一个jsx文件代表一个组件，我们需要根据单一职责原则把一个用户界面拆分为许多组件，组件分为函数式组件（或者称为无状态组件）和类组件，无论是函数式组件还是类组件都会返回一个React元素，这个过程是通过Babel把jsx编译成React.createElement()执行的：
图。。。
函数式组件形如一个javascript函数，它只接受props参数，并返回一个React元素，当我们使用函数式组件的时候，往往只把这个组件用于展示props传入的数据，而没有其他的逻辑，例如对用户的操作作出响应等，所以函数式组件没有自己内部的状态。我们可以看作：给它什么，它就显示并只专注于显示什么。你或许了解函数式编程，函数式组件也一样，当我们使用它的时候，应该禁止其修改传入的props。
图
而在类组件中，组件获得了更多的能力。它可以拥有自己的State（状态），同时它还拥有了在组件不同的生命周期里编写逻辑的能力，从而可以响应更复杂的变化。
（显然，在Facebook内部可能更喜欢函数式组件，否则它们就不会为函数式组件提供新特性Hooks并推荐你在新的代码中使用它了。）
假如我们现在要实现一个功能：有一个搜索框和一个表格用于搜索和展示电影。
首先拆分组件。我们可以把整个功能先看成一个组件，它实现了搜索和展示的功能，这样做当然可以，但如果在应用的另一个地方要实现某个单一的搜索或者展示功能呢？诚然，这样让组件无法复用。所以我们可以拆分为一个搜索组件和一个展示组件，这样使得我们的组件可以在其他地方复用（在应用的设计阶段可以和设计师沟通，把有相同功能的页面设计为一致的风格，如果他要为相同的功能都重新设计，那么就祝你幸福吧）。
现在我们把这个功能拆分为如下的组件构成：
图。。。
我们该如何选择函数式组件和类组件呢？
一个简单的方法就是我们先用类组件构建所有的组件，只实现功能的静态页面版本（只有界面，而没有任何的交互，只需要编写类组件里的render方法），并模拟一个电影数组，通过props传入MovieFilterableTable,然后再传入MovieTable组件。
显然，这个静态页面版本无法满足我们的功能需求，我们的组件需要更多的交互，React为我们提供了State来触发和更改底层的数据模型。
现在列举一下我们功能里的所有数据：
 搜索文本 初始电影列表 搜索后的电影列表  为了确定一个数据是不是State，React提供了几个提示：
 是否通过 props(属性) 从父级传入？ 如果是这样，它可能不是 state(状态) 。 是否永远不会发生变化？ 如果是这样，它可能不是 state(状态)。 是否可以由组件中其他的 state(状态) 或 props(属性) 计算得出？如果是这样，则它不是 state(状态)。  （你或许觉得啰嗦，当你熟悉了React构建应用后，你可以很快的确定哪些数据是state，哪些是props）
搜索文本不是通过props传入，会随着用户的输入改变。初始电影列表通过props传递，而搜索后的电影列表可以通过初试电影列表结合搜索文本计算得出。
所以在这个功能中，状态只有：
 搜索文本  接下来我们要思考该把这个state放在那个组件当中。在React中，数据自顶向下流动，假如搜索文本只有在SearchBar中才使用，那放入SearchBar或许是不错的选择，但在这个例子中，我们的MovieTable组件也需要搜索文本来决定需要展示哪些Movie，MovieTable和SearchBar处于同级，这会让state的共享变得困难，所以把它放入公共父组件并通过props传入SearchBar和MovieTable会是不错的选择。
对于State应该存放在哪个组件当中，React为我们提供了一些建议：
 确定每个基于这个 state(状态) 渲染的组件。 找出公共父级组件（一个单独的组件，在组件层级中位于所有需要这个 state(状态) 的组件的上面。愚人码头注：父级组件）。 公共父级组件 或者 另一个更高级组件拥有这个 state(状态) 。 如果找不出一个拥有该 state(状态) 的合适组件，可以创建一个简单的新组件来保留这个 state(状态) ，并将其添加到公共父级组件的上层即可。  （State和Props的规划，是React中非常重要的一部分，这往往会影响到你对应用的理解和代码的整洁）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/react%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/" />
<meta property="article:published_time" content="2018-11-30T21:37:10+08:00" />
<meta property="article:modified_time" content="2018-11-30T21:37:10+08:00" />


<meta itemprop="name" content="React 开发教程">
<meta itemprop="description" content="最近学了React，所以把自己学习React的笔记整理一下变成了这篇入门教程。
React官方文档描述React为函数式的，有的同学可能不太明白，前端明明涉及那么多有副作用的操作，例如DOM的操作和API的请求之类，为什么React会称自己为函数式的呢？
我们知道，无论是React、Vue或是Angular，它们的最终目的都是生成视图，而视图则是对当前数据的一种映射，在MVVM（关于MVVM可以参考我的另一篇博客）模式里面，我们并不直接操作View层，而是交给VM层自动生成，所以MVVM模式框架生成视图的过程中，我们可以看做：
数据 &#43; Render = 视图
而MVVM模式的框架在生成视图的过程中就扮演了Render的角色。在函数式编程中，当一个函数接受相同的参数，它总是返回相同的结果。而在React中，我们提供了相同的数据，React总是渲染出相同的视图。那些带有副作用的操作，DOM改变和API请求，会先改变数据，然后经过Render最终改变视图，这就是React不建议我们直接操作DOM的原因，这会让视图的生成不可预测，并增加测试的难度。
那么我们如何使用React来构建视图呢？
过去我们不使用React之类的框架时，总是用一个HTML文件来表示一个用户界面，然而一个用户界面在很多时候是复杂的，当产生变化的时候，经常伴随许多DOM操作，所有我们还要提供一个又臭又长的js文件来维护用户界面的变化，当应用越来越懒复杂，用户界面越来越多的时候，可以预见这将是一场灾难。那如果我们不按用户界面来拆分应用呢？我们是否可以把用户界面看做一个个小的视图组成，每一个视图完成一个功能？显然，React这样做了。
在React中，推荐使用jsx来描述UI信息（你也可以使用其他的语言，但是React弄了一个视频来忽悠你），每一个jsx文件代表一个组件，我们需要根据单一职责原则把一个用户界面拆分为许多组件，组件分为函数式组件（或者称为无状态组件）和类组件，无论是函数式组件还是类组件都会返回一个React元素，这个过程是通过Babel把jsx编译成React.createElement()执行的：
图。。。
函数式组件形如一个javascript函数，它只接受props参数，并返回一个React元素，当我们使用函数式组件的时候，往往只把这个组件用于展示props传入的数据，而没有其他的逻辑，例如对用户的操作作出响应等，所以函数式组件没有自己内部的状态。我们可以看作：给它什么，它就显示并只专注于显示什么。你或许了解函数式编程，函数式组件也一样，当我们使用它的时候，应该禁止其修改传入的props。
图
而在类组件中，组件获得了更多的能力。它可以拥有自己的State（状态），同时它还拥有了在组件不同的生命周期里编写逻辑的能力，从而可以响应更复杂的变化。
（显然，在Facebook内部可能更喜欢函数式组件，否则它们就不会为函数式组件提供新特性Hooks并推荐你在新的代码中使用它了。）
假如我们现在要实现一个功能：有一个搜索框和一个表格用于搜索和展示电影。
首先拆分组件。我们可以把整个功能先看成一个组件，它实现了搜索和展示的功能，这样做当然可以，但如果在应用的另一个地方要实现某个单一的搜索或者展示功能呢？诚然，这样让组件无法复用。所以我们可以拆分为一个搜索组件和一个展示组件，这样使得我们的组件可以在其他地方复用（在应用的设计阶段可以和设计师沟通，把有相同功能的页面设计为一致的风格，如果他要为相同的功能都重新设计，那么就祝你幸福吧）。
现在我们把这个功能拆分为如下的组件构成：
图。。。
我们该如何选择函数式组件和类组件呢？
一个简单的方法就是我们先用类组件构建所有的组件，只实现功能的静态页面版本（只有界面，而没有任何的交互，只需要编写类组件里的render方法），并模拟一个电影数组，通过props传入MovieFilterableTable,然后再传入MovieTable组件。
显然，这个静态页面版本无法满足我们的功能需求，我们的组件需要更多的交互，React为我们提供了State来触发和更改底层的数据模型。
现在列举一下我们功能里的所有数据：
 搜索文本 初始电影列表 搜索后的电影列表  为了确定一个数据是不是State，React提供了几个提示：
 是否通过 props(属性) 从父级传入？ 如果是这样，它可能不是 state(状态) 。 是否永远不会发生变化？ 如果是这样，它可能不是 state(状态)。 是否可以由组件中其他的 state(状态) 或 props(属性) 计算得出？如果是这样，则它不是 state(状态)。  （你或许觉得啰嗦，当你熟悉了React构建应用后，你可以很快的确定哪些数据是state，哪些是props）
搜索文本不是通过props传入，会随着用户的输入改变。初始电影列表通过props传递，而搜索后的电影列表可以通过初试电影列表结合搜索文本计算得出。
所以在这个功能中，状态只有：
 搜索文本  接下来我们要思考该把这个state放在那个组件当中。在React中，数据自顶向下流动，假如搜索文本只有在SearchBar中才使用，那放入SearchBar或许是不错的选择，但在这个例子中，我们的MovieTable组件也需要搜索文本来决定需要展示哪些Movie，MovieTable和SearchBar处于同级，这会让state的共享变得困难，所以把它放入公共父组件并通过props传入SearchBar和MovieTable会是不错的选择。
对于State应该存放在哪个组件当中，React为我们提供了一些建议：
 确定每个基于这个 state(状态) 渲染的组件。 找出公共父级组件（一个单独的组件，在组件层级中位于所有需要这个 state(状态) 的组件的上面。愚人码头注：父级组件）。 公共父级组件 或者 另一个更高级组件拥有这个 state(状态) 。 如果找不出一个拥有该 state(状态) 的合适组件，可以创建一个简单的新组件来保留这个 state(状态) ，并将其添加到公共父级组件的上层即可。  （State和Props的规划，是React中非常重要的一部分，这往往会影响到你对应用的理解和代码的整洁）">


<meta itemprop="datePublished" content="2018-11-30T21:37:10&#43;08:00" />
<meta itemprop="dateModified" content="2018-11-30T21:37:10&#43;08:00" />
<meta itemprop="wordCount" content="72">



<meta itemprop="keywords" content="" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="React 开发教程"/>
<meta name="twitter:description" content="最近学了React，所以把自己学习React的笔记整理一下变成了这篇入门教程。
React官方文档描述React为函数式的，有的同学可能不太明白，前端明明涉及那么多有副作用的操作，例如DOM的操作和API的请求之类，为什么React会称自己为函数式的呢？
我们知道，无论是React、Vue或是Angular，它们的最终目的都是生成视图，而视图则是对当前数据的一种映射，在MVVM（关于MVVM可以参考我的另一篇博客）模式里面，我们并不直接操作View层，而是交给VM层自动生成，所以MVVM模式框架生成视图的过程中，我们可以看做：
数据 &#43; Render = 视图
而MVVM模式的框架在生成视图的过程中就扮演了Render的角色。在函数式编程中，当一个函数接受相同的参数，它总是返回相同的结果。而在React中，我们提供了相同的数据，React总是渲染出相同的视图。那些带有副作用的操作，DOM改变和API请求，会先改变数据，然后经过Render最终改变视图，这就是React不建议我们直接操作DOM的原因，这会让视图的生成不可预测，并增加测试的难度。
那么我们如何使用React来构建视图呢？
过去我们不使用React之类的框架时，总是用一个HTML文件来表示一个用户界面，然而一个用户界面在很多时候是复杂的，当产生变化的时候，经常伴随许多DOM操作，所有我们还要提供一个又臭又长的js文件来维护用户界面的变化，当应用越来越懒复杂，用户界面越来越多的时候，可以预见这将是一场灾难。那如果我们不按用户界面来拆分应用呢？我们是否可以把用户界面看做一个个小的视图组成，每一个视图完成一个功能？显然，React这样做了。
在React中，推荐使用jsx来描述UI信息（你也可以使用其他的语言，但是React弄了一个视频来忽悠你），每一个jsx文件代表一个组件，我们需要根据单一职责原则把一个用户界面拆分为许多组件，组件分为函数式组件（或者称为无状态组件）和类组件，无论是函数式组件还是类组件都会返回一个React元素，这个过程是通过Babel把jsx编译成React.createElement()执行的：
图。。。
函数式组件形如一个javascript函数，它只接受props参数，并返回一个React元素，当我们使用函数式组件的时候，往往只把这个组件用于展示props传入的数据，而没有其他的逻辑，例如对用户的操作作出响应等，所以函数式组件没有自己内部的状态。我们可以看作：给它什么，它就显示并只专注于显示什么。你或许了解函数式编程，函数式组件也一样，当我们使用它的时候，应该禁止其修改传入的props。
图
而在类组件中，组件获得了更多的能力。它可以拥有自己的State（状态），同时它还拥有了在组件不同的生命周期里编写逻辑的能力，从而可以响应更复杂的变化。
（显然，在Facebook内部可能更喜欢函数式组件，否则它们就不会为函数式组件提供新特性Hooks并推荐你在新的代码中使用它了。）
假如我们现在要实现一个功能：有一个搜索框和一个表格用于搜索和展示电影。
首先拆分组件。我们可以把整个功能先看成一个组件，它实现了搜索和展示的功能，这样做当然可以，但如果在应用的另一个地方要实现某个单一的搜索或者展示功能呢？诚然，这样让组件无法复用。所以我们可以拆分为一个搜索组件和一个展示组件，这样使得我们的组件可以在其他地方复用（在应用的设计阶段可以和设计师沟通，把有相同功能的页面设计为一致的风格，如果他要为相同的功能都重新设计，那么就祝你幸福吧）。
现在我们把这个功能拆分为如下的组件构成：
图。。。
我们该如何选择函数式组件和类组件呢？
一个简单的方法就是我们先用类组件构建所有的组件，只实现功能的静态页面版本（只有界面，而没有任何的交互，只需要编写类组件里的render方法），并模拟一个电影数组，通过props传入MovieFilterableTable,然后再传入MovieTable组件。
显然，这个静态页面版本无法满足我们的功能需求，我们的组件需要更多的交互，React为我们提供了State来触发和更改底层的数据模型。
现在列举一下我们功能里的所有数据：
 搜索文本 初始电影列表 搜索后的电影列表  为了确定一个数据是不是State，React提供了几个提示：
 是否通过 props(属性) 从父级传入？ 如果是这样，它可能不是 state(状态) 。 是否永远不会发生变化？ 如果是这样，它可能不是 state(状态)。 是否可以由组件中其他的 state(状态) 或 props(属性) 计算得出？如果是这样，则它不是 state(状态)。  （你或许觉得啰嗦，当你熟悉了React构建应用后，你可以很快的确定哪些数据是state，哪些是props）
搜索文本不是通过props传入，会随着用户的输入改变。初始电影列表通过props传递，而搜索后的电影列表可以通过初试电影列表结合搜索文本计算得出。
所以在这个功能中，状态只有：
 搜索文本  接下来我们要思考该把这个state放在那个组件当中。在React中，数据自顶向下流动，假如搜索文本只有在SearchBar中才使用，那放入SearchBar或许是不错的选择，但在这个例子中，我们的MovieTable组件也需要搜索文本来决定需要展示哪些Movie，MovieTable和SearchBar处于同级，这会让state的共享变得困难，所以把它放入公共父组件并通过props传入SearchBar和MovieTable会是不错的选择。
对于State应该存放在哪个组件当中，React为我们提供了一些建议：
 确定每个基于这个 state(状态) 渲染的组件。 找出公共父级组件（一个单独的组件，在组件层级中位于所有需要这个 state(状态) 的组件的上面。愚人码头注：父级组件）。 公共父级组件 或者 另一个更高级组件拥有这个 state(状态) 。 如果找不出一个拥有该 state(状态) 的合适组件，可以创建一个简单的新组件来保留这个 state(状态) ，并将其添加到公共父级组件的上层即可。  （State和Props的规划，是React中非常重要的一部分，这往往会影响到你对应用的理解和代码的整洁）"/>


    </head>
<body>
    <nav class="main-nav">
	
		<a href='/'> <span class="arrow">←</span>Home</a>
	

	

	
		<a class="cta" href="/index.xml">Subscribe</a>
	
</nav>

    <section id="wrapper">
        
        
<article class="post">
    <header>
        <h1>React 开发教程</h1>
        <h2 class="subtitle"></h2>
        <h2 class="headline">
        November 30, 2018
        <br>
        
        </h2>
    </header>
    <section id="post-body">
        <p>最近学了React，所以把自己学习React的笔记整理一下变成了这篇入门教程。</p>

<p>React官方文档描述React为函数式的，有的同学可能不太明白，前端明明涉及那么多有副作用的操作，例如DOM的操作和API的请求之类，为什么React会称自己为函数式的呢？</p>

<p>我们知道，无论是React、Vue或是Angular，它们的最终目的都是生成视图，而视图则是对当前数据的一种映射，在MVVM（关于MVVM可以参考我的另一篇博客）模式里面，我们并不直接操作View层，而是交给VM层自动生成，所以MVVM模式框架生成视图的过程中，我们可以看做：</p>

<p>数据  +  Render = 视图</p>

<p>而MVVM模式的框架在生成视图的过程中就扮演了Render的角色。在函数式编程中，当一个函数接受相同的参数，它总是返回相同的结果。而在React中，我们提供了相同的数据，React总是渲染出相同的视图。那些带有副作用的操作，DOM改变和API请求，会先改变数据，然后经过Render最终改变视图，这就是React不建议我们直接操作DOM的原因，这会让视图的生成不可预测，并增加测试的难度。</p>

<p>那么我们如何使用React来构建视图呢？</p>

<p>过去我们不使用React之类的框架时，总是用一个HTML文件来表示一个用户界面，然而一个用户界面在很多时候是复杂的，当产生变化的时候，经常伴随许多DOM操作，所有我们还要提供一个又臭又长的js文件来维护用户界面的变化，当应用越来越懒复杂，用户界面越来越多的时候，可以预见这将是一场灾难。那如果我们不按用户界面来拆分应用呢？我们是否可以把用户界面看做一个个小的视图组成，每一个视图完成一个功能？显然，React这样做了。</p>

<p>在React中，推荐使用jsx来描述UI信息（你也可以使用其他的语言，但是React弄了一个视频来忽悠你），每一个jsx文件代表一个组件，我们需要根据单一职责原则把一个用户界面拆分为许多组件，组件分为函数式组件（或者称为无状态组件）和类组件，无论是函数式组件还是类组件都会返回一个React元素，这个过程是通过Babel把jsx编译成React.createElement()执行的：</p>

<p>图。。。</p>

<p>函数式组件形如一个javascript函数，它只接受props参数，并返回一个React元素，当我们使用函数式组件的时候，往往只把这个组件用于展示props传入的数据，而没有其他的逻辑，例如对用户的操作作出响应等，所以函数式组件没有自己内部的状态。我们可以看作：给它什么，它就显示并只专注于显示什么。你或许了解函数式编程，函数式组件也一样，当我们使用它的时候，应该禁止其修改传入的props。</p>

<p>图</p>

<p>而在类组件中，组件获得了更多的能力。它可以拥有自己的State（状态），同时它还拥有了在组件不同的生命周期里编写逻辑的能力，从而可以响应更复杂的变化。</p>

<p>（显然，在Facebook内部可能更喜欢函数式组件，否则它们就不会为函数式组件提供新特性Hooks并推荐你在新的代码中使用它了。）</p>

<p>假如我们现在要实现一个功能：有一个搜索框和一个表格用于搜索和展示电影。</p>

<p>首先拆分组件。我们可以把整个功能先看成一个组件，它实现了搜索和展示的功能，这样做当然可以，但如果在应用的另一个地方要实现某个单一的搜索或者展示功能呢？诚然，这样让组件无法复用。所以我们可以拆分为一个搜索组件和一个展示组件，这样使得我们的组件可以在其他地方复用（在应用的设计阶段可以和设计师沟通，把有相同功能的页面设计为一致的风格，如果他要为相同的功能都重新设计，那么就祝你幸福吧）。</p>

<p>现在我们把这个功能拆分为如下的组件构成：</p>

<p>图。。。</p>

<p>我们该如何选择函数式组件和类组件呢？</p>

<p>一个简单的方法就是我们先用类组件构建所有的组件，只实现功能的静态页面版本（只有界面，而没有任何的交互，只需要编写类组件里的render方法），并模拟一个电影数组，通过props传入MovieFilterableTable,然后再传入MovieTable组件。</p>

<p>显然，这个静态页面版本无法满足我们的功能需求，我们的组件需要更多的交互，React为我们提供了State来触发和更改底层的数据模型。</p>

<p>现在列举一下我们功能里的所有数据：</p>

<ul>
<li>搜索文本</li>
<li>初始电影列表</li>
<li>搜索后的电影列表</li>
</ul>

<p>为了确定一个数据是不是State，React提供了几个提示：</p>

<ol>
<li>是否通过 props(属性) 从父级传入？ 如果是这样，它可能不是 state(状态) 。</li>
<li>是否永远不会发生变化？ 如果是这样，它可能不是 state(状态)。</li>
<li>是否可以由组件中其他的 state(状态) 或 props(属性) 计算得出？如果是这样，则它不是 state(状态)。</li>
</ol>

<p>（你或许觉得啰嗦，当你熟悉了React构建应用后，你可以很快的确定哪些数据是state，哪些是props）</p>

<p>搜索文本不是通过props传入，会随着用户的输入改变。初始电影列表通过props传递，而搜索后的电影列表可以通过初试电影列表结合搜索文本计算得出。</p>

<p>所以在这个功能中，状态只有：</p>

<ul>
<li>搜索文本</li>
</ul>

<p>接下来我们要思考该把这个state放在那个组件当中。在React中，数据自顶向下流动，假如搜索文本只有在SearchBar中才使用，那放入SearchBar或许是不错的选择，但在这个例子中，我们的MovieTable组件也需要搜索文本来决定需要展示哪些Movie，MovieTable和SearchBar处于同级，这会让state的共享变得困难，所以把它放入公共父组件并通过props传入SearchBar和MovieTable会是不错的选择。</p>

<p>对于State应该存放在哪个组件当中，React为我们提供了一些建议：</p>

<ul>
<li>确定每个基于这个 state(状态) 渲染的组件。</li>
<li>找出公共父级组件（一个单独的组件，在组件层级中位于所有需要这个 state(状态) 的组件的上面。愚人码头注：父级组件）。</li>
<li>公共父级组件 或者 另一个更高级组件拥有这个 state(状态) 。</li>
<li>如果找不出一个拥有该 state(状态) 的合适组件，可以创建一个简单的新组件来保留这个 state(状态) ，并将其添加到公共父级组件的上层即可。</li>
</ul>

<p>（State和Props的规划，是React中非常重要的一部分，这往往会影响到你对应用的理解和代码的整洁）</p>

<p>看起来我们已经让这个功能具备了正确的数据流，但我们似乎忽略了一点：SearchBar需要更改搜索文本这个State该怎么做？</p>

<p>由于组件只能修改自己的State，但是搜索文本是存放在父组件中通过props传入SearchBar的，当用户输入新的文本时，我们可以使用OnChange监听用户的输入，然后通过父组件传入的回调调用setState，然后应用就被更新。</p>

<p>到这一步我们就把一个简单的功能实现了，对于React应用而言，就是由许多个这样的功能组件组合而成：</p>

<p>图。。。。</p>

<p>这种模块化、可复用的代码结构在我们构建大型应用的时候变得更加容易</p>

    </section>
</article>

<footer id="post-meta" class="clearfix">
    
    <img class="avatar" src="/images/avatar.png">
    <div>
        <span class="dark">Nam</span>
        <span>在路上</span>
    </div>
    
    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=%2fposts%2freact%25E5%25BC%2580%25E5%258F%2591%25E6%2595%2599%25E7%25A8%258B%2f - React%20%e5%bc%80%e5%8f%91%e6%95%99%e7%a8%8b "><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

    </section>
</footer>



<ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/posts/v8%E5%BC%95%E6%93%8E%E9%87%8C%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">V8引擎里的内存管理<aside class="dates">Oct 22 2019</aside></a>
        </li>
    
        <li>
            <a href="/posts/how-to-use-proxy/">How to use Proxy<aside class="dates">Feb 3 2018</aside></a>
        </li>
    
        <li>
            <a href="/posts/%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/">一道面试题<aside class="dates">Jan 10 2018</aside></a>
        </li>
    
        <li>
            <a href="/posts/js%E9%87%8C%E7%9A%84%E7%BB%A7%E6%89%BF/">Js里的继承<aside class="dates">Jan 2 2018</aside></a>
        </li>
    
        <li>
            <a href="/posts/this%E6%8C%87%E5%90%91/">This指向<aside class="dates">Oct 22 2017</aside></a>
        </li>
    
        <li>
            <a href="/posts/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">Js的基本类型<aside class="dates">Jan 1 0001</aside></a>
        </li>
    
</ul>



        <footer id="footer">
    
        <div id="social">

	
	
    
    <a class="symbol" href="https://Lennam.github.com/">
        circlegithub
    </a>
    


</div>

    
    <p class="small">
    
        © Copyright 2019 Nam
    
    </p>
</footer>

    </section>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script>





</body>
</html>
